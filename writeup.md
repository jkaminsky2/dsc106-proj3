## Important Links

**Visualization**: https://jkaminsky2.github.io/dsc106-proj3/

**Main code for visualization**: https://github.com/jkaminsky2/dsc106-proj3/blob/main/416392da175798b4%40182.js

**Dataset (datasets we used located in static folder)**: https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/VOQCHQ

**Source code**: https://observablehq.com/@d3/zoom-to-bounding-box?intent=fork

# Write-Up

For project 3, we decided to create an interactive visualization based around past presidential elections. Using the data from https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/VOQCHQ, we wanted to create a visualization that would allow users to explore the presidential elections from 2000 to 2020. This dataset includes county results for each U.S. county for each presidential candidate for the 2000 presidential election through the 2020 presidential election. To allow users to explore the data, we decided to include the overall results but also break down these overall results into state-by-state results. This led to the following research question: what is the overall result and state breakdown of U.S. presidential elections from 2000 to 2020? 

To answer the question, we first needed a base U.S. map, which we sourced from https://observablehq.com/@d3/zoom-to-bounding-box?intent=fork. We then needed to figure out how to visualize the data on the map. To get the data to answer our questions, we created the following datasets from the sourced dataset: a dataset for overall results for each presidential election (in terms of electoral college votes), one with the winner for each state for each election year, and the dataset itself. To visualize the overall results for each presidential election, we went with a horizontal stacked bar plot, which is common for this type of data visualization. This is because you can put a line at 270 votes (which is the minimum number of electoral votes to win the election) and whichever color is on both sides of the line is the winner of the election (as 270 is the middle number, so a number greater than 270 would go past this line). As for displaying the results by state, we chose to use a choropleth map; we did this as it can easily show the winner of the state based on its color. Finally, for the actual results by state, we felt it was best to use a pie chart; this allows us to show what proportion of votes each candidate received in that state, where this value (and the winner of the state) is easily interpreted by the size of the slice of the pie.

For interaction techniques, we concluded that the needed interactivity was to be able to select which election to see (based on year), see each state's result by clicking on it, and being able to investigate the pie chart. To let users see which election to visualize, we included a button at the top of the screen; therefore, users could not miss it and begin identifying patterns election by election. To do this, we encoded a basic button with contextual words next to it so users knew what they were doing with the button. As for interactivity with states, it was important for us that users could drag the map around in any direction and zoom in and out of particular states. This was done so users did not feel confined to just choosing a state, which would limit interactivity and interest with messing with the visualization. Lastly, we added interactivity to the pie chart in the form of a text box of data when highlighting over a slice. This was done as not every slice was big enough to display data regarding that slice within it (number of votes the candidate received and what proportion of the total votes it is).

On top of the interactivity, states and the pie chart needed to be properly color-coded (red for Republicans, blue for Democrats, green for Green Party, gold for Libretarian, and then gray for other). Furthermore, the pie chart needed to be contextualized; to do this, we added a color-coded key to show which slice of the pie chart is for each candidate (to reinforce the color-coding) and a title of the state the pie chart is referring to. For the stacked bar chart, we limited it to the Democrat and Republican candidates as those are the only ones who actually won states from 2000 to 2020. We also added the candidate name, in addition to properly color-coding it (red for Republicans, blue for Democrats), to further contextualize who each bar is referring to. Finally, as mentioned prior, a line at 270 was drawn and labeled as "Goal" because a candidate needs at least 270 electoral votes to win the election.

For interactivity, we wanted to include other things but ran out of time. One example is a county-level view. A county-level view could show users voting pattern clusters that are not evident at the state-level view. Another example is a search bar to look up states or regions. This would expand the interactivity, where looking at regions of the U.S. would provide another view of presidential election voting patterns beyond by state. We ended up with the interactivity choices we used as we believe that they allow for a sufficient amount of interactivity with the map, where the other interactivity options we considered would not be necessary for the goal of the visualization (let users explore nationwide and state-wide presidential election trends from 2000 to 2020).

To create our visualization, we decided to create the infrastructure with made-up, basic data and then pipeline the data and add interactivity tools after. To begin, we figured out how to color-code the base map we sourced. After that, we implemented the pie chart (with stand-in, fake data), stacked, horizontal bar plot, and the transition for zooming into a state and zooming out. To complete the infrastructure, we added a button to let users select a presidential election year to look at. After completing these, we uploaded our datasets and wrote the code to read them in. Then, we made edits to our previous code to read in the real data (the stacked bar chart, state color, and pie chart data); to account for changes in election year, we added the function updateChart to rerun out _chart function so that it would update the visualization to use the appropriate data. Finally, we implemented the pie chart interactivity, where we color-coded it, added the hover text box, and added transitions. The final step was testing everything to make sure transitions worked, everything was properly synchronized, and that all interactivity tools worked and accurately updated the map.

From cleaning the data to creating the visualization infrastructure and piping in the data, it took 30 hours of work. We usually took a divide and conquer model where we each tried to implement something new locally and then added it to the GitHub page. If someone was stuck, we worked together to fix the issue. What took the longest was editing the code to allow for the interactivity. While we thought it was a good idea to set up the infrastructure (to get an idea of how to implement everything), it ultimately proved to be less efficient than trying to create the final code (using the presidential election data) right away. On top of creating code to read in the data, every function needed to be edited to be generalized and the updateChart function needed to be created; this took a while as trying to pipe in the data came with many errors, where numerous workarounds were needed. While this project was challenging, it was definitely worth it when looking at the final product.
